use std::fs;
use std::path::Path;

use crate::cmd::{
    ConfigResponse, DocumentListResponse, DocumentResponse, GraphEdgeDto, GraphNodeDto,
    InitialSettings, RoleGraphResponse, SearchResponse, Status,
};
use terraphim_automata::AutomataPath;
use terraphim_config::{
    Config, ConfigId, Haystack, KnowledgeGraph, KnowledgeGraphLocal, Role, ServiceType,
};
use terraphim_types::{
    Document, KnowledgeGraphInputType, LogicalOperator, NormalizedTermValue, RelevanceFunction,
    RoleName, SearchQuery,
};
use tsify::Tsify;

/// Generate TypeScript bindings for all Rust types that are used in the Tauri commands
pub fn generate_typescript_bindings() -> Result<(), Box<dyn std::error::Error>> {
    let bindings_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("../src/lib/generated");

    // Create the directory if it doesn't exist
    if !bindings_dir.exists() {
        fs::create_dir_all(&bindings_dir)?;
    }

    // Generate bindings for each type
    let mut all_bindings = String::new();

    // Header comment
    all_bindings.push_str("// This file is auto-generated by tsify. Do not edit manually.\n");
    all_bindings.push_str("// Run `cargo run --bin generate-bindings` to regenerate.\n\n");

    // Helper types used across bindings
    all_bindings.push_str("// === Helper Types ===\n");
    all_bindings.push_str("export type Value = unknown;\n");
    all_bindings.push('\n');
    all_bindings.push_str(
        "export type AHashMap<K = string | number, V = unknown> = Record<string, V> & Partial<Record<number, V>>;\n",
    );
    all_bindings.push('\n');

    // Core types from terraphim_types
    all_bindings.push_str("// === Core Types ===\n");
    all_bindings.push_str(RoleName::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(NormalizedTermValue::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(Document::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(LogicalOperator::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(SearchQuery::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(RelevanceFunction::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(KnowledgeGraphInputType::DECL);
    all_bindings.push('\n');

    // Automata types from terraphim_automata
    all_bindings.push_str("// === Automata Types ===\n");
    all_bindings.push_str(AutomataPath::DECL);
    all_bindings.push('\n');

    // Config types from terraphim_config
    all_bindings.push_str("// === Configuration Types ===\n");
    all_bindings.push_str(ServiceType::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(Haystack::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(KnowledgeGraphLocal::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(KnowledgeGraph::DECL);
    all_bindings.push('\n');
    let role_decl = Role::DECL.replace(
        "[key: string]: Value; // Allow additional properties",
        "[key: string]: unknown; // Allow additional properties",
    );
    all_bindings.push_str(&role_decl);
    all_bindings.push('\n');
    all_bindings.push_str(ConfigId::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(Config::DECL);
    all_bindings.push('\n');

    // Command response types
    all_bindings.push_str("// === Command Response Types ===\n");
    all_bindings.push_str(Status::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(ConfigResponse::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(SearchResponse::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(DocumentListResponse::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(DocumentResponse::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(InitialSettings::DECL);
    all_bindings.push('\n');

    // Role graph visualization types
    all_bindings.push_str("// === Role Graph Visualization Types ===\n");
    all_bindings.push_str(GraphNodeDto::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(GraphEdgeDto::DECL);
    all_bindings.push('\n');
    all_bindings.push_str(RoleGraphResponse::DECL);
    all_bindings.push('\n');

    // Write to the bindings file
    let bindings_path = bindings_dir.join("types.ts");
    let sanitized_bindings =
        all_bindings.replace("[key: string]: Value;", "[key: string]: unknown;");
    fs::write(bindings_path, sanitized_bindings)?;

    println!("âœ… TypeScript bindings generated successfully!");

    Ok(())
}

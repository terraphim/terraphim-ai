#[cfg(test)]
mod logical_operators_tests {
    use super::*;
    use terraphim_config::{ConfigBuilder, ConfigId};
    use terraphim_service::TerraphimService;
    use terraphim_types::{Document, LogicalOperator, NormalizedTermValue, RoleName, SearchQuery};
    use tokio_test;

    async fn setup_test_service() -> TerraphimService {
        let config = ConfigBuilder::new_with_id(ConfigId::Embedded)
            .build_default_embedded()
            .build()
            .unwrap();
        let config_state = terraphim_config::ConfigState::new(&config).await.unwrap();
        TerraphimService::new(config_state)
    }

    #[tokio::test]
    async fn test_logical_and_operation() {
        let service = setup_test_service().await;

        let query = SearchQuery {
            search_term: NormalizedTermValue::from("rust"),
            search_terms: Some(vec![
                NormalizedTermValue::from("rust"),
                NormalizedTermValue::from("async"),
            ]),
            operator: Some(LogicalOperator::And),
            skip: Some(0),
            limit: Some(10),
            role: Some(RoleName::from("Engineer")),
        };

        // This test verifies the query structure is properly formed
        // In a real scenario, this would test against actual documents
        assert_eq!(query.operator, Some(LogicalOperator::And));
        assert_eq!(query.search_terms.as_ref().unwrap().len(), 2);
        assert_eq!(query.search_terms.as_ref().unwrap()[0].value, "rust");
        assert_eq!(query.search_terms.as_ref().unwrap()[1].value, "async");
    }

    #[tokio::test]
    async fn test_logical_or_operation() {
        let service = setup_test_service().await;

        let query = SearchQuery {
            search_term: NormalizedTermValue::from("api"),
            search_terms: Some(vec![
                NormalizedTermValue::from("api"),
                NormalizedTermValue::from("sdk"),
                NormalizedTermValue::from("library"),
            ]),
            operator: Some(LogicalOperator::Or),
            skip: Some(0),
            limit: Some(10),
            role: Some(RoleName::from("Engineer")),
        };

        assert_eq!(query.operator, Some(LogicalOperator::Or));
        assert_eq!(query.search_terms.as_ref().unwrap().len(), 3);
    }

    #[tokio::test]
    async fn test_single_term_search_backward_compatibility() {
        let service = setup_test_service().await;

        let query = SearchQuery {
            search_term: NormalizedTermValue::from("rust"),
            search_terms: None,
            operator: None,
            skip: Some(0),
            limit: Some(10),
            role: Some(RoleName::from("Engineer")),
        };

        // Verify backward compatibility for single-term searches
        assert!(query.operator.is_none());
        assert!(query.search_terms.is_none());
        assert_eq!(query.search_term.value, "rust");
    }

    #[tokio::test]
    async fn test_apply_logical_operators_and() {
        let service = setup_test_service().await;

        // Mock documents for testing
        let doc1 = Document {
            id: "1".to_string(),
            url: "http://example.com/1".to_string(),
            body: "This is about rust programming".to_string(),
            description: Some("Rust programming guide".to_string()),
            tags: Some(vec!["rust".to_string(), "programming".to_string()]),
            rank: Some(0.8),
        };

        let doc2 = Document {
            id: "2".to_string(),
            url: "http://example.com/2".to_string(),
            body: "This covers async programming in rust".to_string(),
            description: Some("Async Rust tutorial".to_string()),
            tags: Some(vec!["rust".to_string(), "async".to_string()]),
            rank: Some(0.9),
        };

        let doc3 = Document {
            id: "3".to_string(),
            url: "http://example.com/3".to_string(),
            body: "JavaScript async programming".to_string(),
            description: Some("JS async guide".to_string()),
            tags: Some(vec!["javascript".to_string(), "async".to_string()]),
            rank: Some(0.7),
        };

        let documents = vec![doc1, doc2, doc3];
        let search_terms = vec![
            NormalizedTermValue::from("rust"),
            NormalizedTermValue::from("async"),
        ];

        // Test AND operation - should return only documents containing both terms
        let result = service.apply_logical_operators_to_documents(
            documents.clone(),
            &search_terms,
            &LogicalOperator::And,
        );

        // Only doc2 contains both "rust" and "async"
        assert_eq!(result.len(), 1);
        assert_eq!(result[0].id, "2");
    }

    #[tokio::test]
    async fn test_apply_logical_operators_or() {
        let service = setup_test_service().await;

        // Mock documents for testing
        let doc1 = Document {
            id: "1".to_string(),
            url: "http://example.com/1".to_string(),
            body: "This is about rust programming".to_string(),
            description: Some("Rust programming guide".to_string()),
            tags: Some(vec!["rust".to_string(), "programming".to_string()]),
            rank: Some(0.8),
        };

        let doc2 = Document {
            id: "2".to_string(),
            url: "http://example.com/2".to_string(),
            body: "JavaScript async programming".to_string(),
            description: Some("JS async guide".to_string()),
            tags: Some(vec!["javascript".to_string(), "async".to_string()]),
            rank: Some(0.7),
        };

        let doc3 = Document {
            id: "3".to_string(),
            url: "http://example.com/3".to_string(),
            body: "Python web development".to_string(),
            description: Some("Python web tutorial".to_string()),
            tags: Some(vec!["python".to_string(), "web".to_string()]),
            rank: Some(0.6),
        };

        let documents = vec![doc1, doc2, doc3];
        let search_terms = vec![
            NormalizedTermValue::from("rust"),
            NormalizedTermValue::from("async"),
        ];

        // Test OR operation - should return documents containing either term
        let result = service.apply_logical_operators_to_documents(
            documents.clone(),
            &search_terms,
            &LogicalOperator::Or,
        );

        // doc1 contains "rust", doc2 contains "async", doc3 contains neither
        assert_eq!(result.len(), 2);
        assert!(result.iter().any(|d| d.id == "1"));
        assert!(result.iter().any(|d| d.id == "2"));
        assert!(!result.iter().any(|d| d.id == "3"));
    }

    #[tokio::test]
    async fn test_empty_documents_list() {
        let service = setup_test_service().await;

        let documents = vec![];
        let search_terms = vec![
            NormalizedTermValue::from("rust"),
            NormalizedTermValue::from("async"),
        ];

        let result_and = service.apply_logical_operators_to_documents(
            documents.clone(),
            &search_terms,
            &LogicalOperator::And,
        );

        let result_or = service.apply_logical_operators_to_documents(
            documents,
            &search_terms,
            &LogicalOperator::Or,
        );

        assert!(result_and.is_empty());
        assert!(result_or.is_empty());
    }

    #[tokio::test]
    async fn test_logical_operator_serialization() {
        use serde_json;

        let and_op = LogicalOperator::And;
        let or_op = LogicalOperator::Or;

        let and_json = serde_json::to_string(&and_op).unwrap();
        let or_json = serde_json::to_string(&or_op).unwrap();

        assert_eq!(and_json, r#""and""#);
        assert_eq!(or_json, r#""or""#);

        let deserialized_and: LogicalOperator = serde_json::from_str(&and_json).unwrap();
        let deserialized_or: LogicalOperator = serde_json::from_str(&or_json).unwrap();

        assert_eq!(deserialized_and, LogicalOperator::And);
        assert_eq!(deserialized_or, LogicalOperator::Or);
    }

    #[tokio::test]
    async fn test_search_query_with_operators_serialization() {
        use serde_json;

        let query = SearchQuery {
            search_term: NormalizedTermValue::from("rust"),
            search_terms: Some(vec![
                NormalizedTermValue::from("rust"),
                NormalizedTermValue::from("async"),
            ]),
            operator: Some(LogicalOperator::And),
            skip: Some(0),
            limit: Some(10),
            role: Some(RoleName::from("Engineer")),
        };

        let json = serde_json::to_string(&query).unwrap();
        let deserialized: SearchQuery = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.operator, Some(LogicalOperator::And));
        assert_eq!(deserialized.search_terms.as_ref().unwrap().len(), 2);
        assert_eq!(deserialized.search_term.value, "rust");
    }

    #[tokio::test]
    async fn test_case_insensitive_matching() {
        let service = setup_test_service().await;

        let doc1 = Document {
            id: "1".to_string(),
            url: "http://example.com/1".to_string(),
            body: "This is about RUST programming".to_string(),
            description: Some("Rust programming guide".to_string()),
            tags: Some(vec!["RUST".to_string(), "programming".to_string()]),
            rank: Some(0.8),
        };

        let doc2 = Document {
            id: "2".to_string(),
            url: "http://example.com/2".to_string(),
            body: "This covers Async programming".to_string(),
            description: Some("Async tutorial".to_string()),
            tags: Some(vec!["async".to_string(), "programming".to_string()]),
            rank: Some(0.9),
        };

        let documents = vec![doc1, doc2];
        let search_terms = vec![
            NormalizedTermValue::from("rust"),
            NormalizedTermValue::from("async"),
        ];

        let result = service.apply_logical_operators_to_documents(
            documents,
            &search_terms,
            &LogicalOperator::Or,
        );

        // Both documents should match despite case differences
        assert_eq!(result.len(), 2);
    }
}
